
/* lib/terminal/server/methodPOST - The library for handling all traffic related to HTTP requests with method POST. */

import { IncomingMessage, ServerResponse } from "http";
import { StringDecoder } from "string_decoder";

import browser from "../test/application/browser.js";
import hash from "../commands/hash.js";
import heartbeat from "./heartbeat.js";
import httpClient from "./httpClient.js";
import invite from "./invite.js";
import log from "../utilities/log.js";
import message from "./message.js";
import response from "./response.js";
import routeCopy from "../fileService/routeCopy.js";
import routeFile from "../fileService/routeFile.js";
import serverVars from "./serverVars.js";
import serviceCopy from "../fileService/serviceCopy.js";
import storage from "./storage.js";
import user from "../fileService/user.js";
import vars from "../utilities/vars.js";

const methodPOST = function terminal_server_methodPOST(request:IncomingMessage, serverResponse:ServerResponse) {
    let body:string = "";
    const decoder:StringDecoder = new StringDecoder("utf8"),
        requestEnd = function terminal_server_methodPOST_requestEnd():void {
            const task:requestType = (request.headers["request-type"].indexOf("invite") === 0)
                    ? "invite"
                    : <requestType>request.headers["request-type"],
                actions:postActions = {
                    "agent-online": function terminal_server_methodPOST_requestEnd_agentOnline():void {
                        // * processes the response for the agent-online terminal command utility
                        const host:string = (request.headers["agent-type"] === "device")
                            ? serverVars.hashDevice
                            : serverVars.hashUser;
                        response({
                            message: `response from ${host}`,
                            mimeType: "text/plain",
                            responseType: "agent-online",
                            serverResponse: serverResponse
                        });
                    },
                    "browser-log": function terminal_server_methodPOST_requestEnd_browserLog():void {
                        const data:any[] = JSON.parse(body),
                            browserIndex:number = serverVars.testType.indexOf("browser");
                        if (browserIndex < 0 || (browserIndex === 0 && data[0] !== null && data[0].toString().indexOf("Executing delay on test number") !== 0)) {
                            log(data);
                        }
                        response({
                            message: "browser log received",
                            mimeType: "text/plain",
                            responseType: "browser-log",
                            serverResponse: serverResponse
                        });
                    },
                    "copy": function terminal_server_methodPOST_requestEnd_copy():void {
                        // * file system asset movement for both local and remote
                        routeCopy(serverResponse, body);
                    },
                    "copy-file": function terminal_server_methodPOST_requestEnd_copyFile():void {
                        // * send file contents as an HTTP response
                        const data:copyFileRequest = JSON.parse(body);
                        serviceCopy.actions.sendFile(serverResponse, data);
                    },
                    "copy-request-files": function terminal_server_methodPOST_requestEnd_copyRequestFile():void {
                        // * request individual files from a list generated by serviceCopy.actions.requestList
                        const data:systemRequestFiles = JSON.parse(body);
                        serviceCopy.actions.requestFiles(serverResponse, data);
                    },
                    "delete-agents": function terminal_server_methodPOST_requestEnd_deleteAgents():void {
                        // * received a request from the browser to delete agents
                        heartbeat.delete(JSON.parse(body), serverResponse);
                    },
                    "fs": function terminal_server_methodPOST_requestEnd_fs():void {
                        // * file system interaction for both local and remote
                        routeFile(serverResponse, body);
                    },
                    "file-list-status-device": function terminal_server_methodPOST_requestEnd_fileListStatusDevice():void {
                        vars.broadcast("file-list-status-device", body);
                        response({
                            message: "File list status response.",
                            mimeType: "text/plain",
                            responseType: "response-no-action",
                            serverResponse: serverResponse
                        });
                    },
                    "file-list-status-user": function terminal_server_methodPOST_requestEnd_fileListStatusUser():void {
                        // * remote: Changes to the remote user's file system
                        // * local : Update local "File Navigator" modals for the respective remote user
                        const status:fileStatusMessage = JSON.parse(body);
                        if (status.agentType === "user") {
                            const devices:string[] = Object.keys(serverVars.device),
                                sendStatus = function terminal_server_methodPOST_requestEnd_fileListStatus_sendStatus(agent:string):void {
                                    httpClient({
                                        agentType: "device",
                                        callback: function terminal_server_methodPOST_requestEnd_fileListStatus_sendStatus_callback():void {},
                                        errorMessage: `Error sending status update to ${agent} of type "device" about location ${status.address} from user ${status.agent}.`,
                                        ip: serverVars.device[agent].ip,
                                        payload: body,
                                        port: serverVars.device[agent].port,
                                        requestError: function terminal_server_methodPOST_requestEnd_fileListStatus_sendStatus_requestError():void {},
                                        requestType: "file-list-status-device",
                                        responseError: function terminal_server_methodPOST_requestEnd_fileListStatus_sendStatus_responseError():void {},
                                        responseStream: httpClient.stream
                                    });
                                };
                            let a:number = devices.length;
                            do {
                                a = a - 1;
                                if (devices[a] !== serverVars.hashDevice) {
                                    sendStatus(devices[a]);
                                }
                            } while (a > 0);
                        }
                        vars.broadcast("file-list-status-device", body);
                        response({
                            message: "File list status response.",
                            mimeType: "text/plain",
                            responseType: "response-no-action",
                            serverResponse: serverResponse
                        });
                    },
                    "hash-device": function terminal_server_methodPOST_requestEnd_hashDevice():void {
                        // * produce a hash that describes a new device
                        const data:hashAgent = JSON.parse(body),
                            hashes:hashAgent = {
                                device: "",
                                user: ""
                            },
                            callbackUser = function terminal_server_methodPOST_requestEnd_hashUser(hashUser:hashOutput) {
                                const callbackDevice = function terminal_server_methodPOST_requestEnd_hashUser_hashDevice(hashDevice:hashOutput) {
                                    serverVars.hashDevice = hashDevice.hash;
                                    serverVars.nameDevice = data.device;
                                    serverVars.device[serverVars.hashDevice] = {
                                        ip: serverVars.ipAddress,
                                        name: data.device,
                                        port: serverVars.webPort,
                                        shares: {}
                                    };
                                    hashes.device = hashDevice.hash;
                                    storage({
                                        data: serverVars.device,
                                        response: null,
                                        type: "device"
                                    });
                                    response({
                                        message: JSON.stringify(hashes),
                                        mimeType: "application/json",
                                        responseType: "hash-user",
                                        serverResponse: serverResponse
                                    });
                                };
                                serverVars.hashUser = hashUser.hash;
                                serverVars.nameUser = data.user;
                                hashes.user = hashUser.hash;
                                input.callback = callbackDevice;
                                input.source = hashUser.hash + data.device;
                                hash(input);
                            },
                            input:hashInput = {
                                algorithm: "sha3-512",
                                callback: callbackUser,
                                directInput: true,
                                source: data.user + vars.node.os.hostname() + process.env.os + process.hrtime.bigint().toString()
                            };
                        hash(input);
                    },
                    "hash-share": function terminal_server_methodPOST_requestEnd_hashShare():void {
                        // * generate a hash string to name a share
                        const data:hashShare = JSON.parse(body),
                            input:hashInput = {
                                algorithm: "sha3-512",
                                callback: function terminal_server_methodPOST_requestEnd_shareHash(hashData:hashOutput) {
                                    const outputBody:hashShare = JSON.parse(hashData.id),
                                        hashResponse:hashShareResponse = {
                                            device: outputBody.device,
                                            hash: hashData.hash,
                                            share: outputBody.share,
                                            type: outputBody.type
                                        };
                                    response({
                                        message: JSON.stringify(hashResponse),
                                        mimeType: "application/json",
                                        responseType: "hash-share",
                                        serverResponse: serverResponse
                                    });
                                },
                                directInput: true,
                                id: body,
                                source: serverVars.hashUser + serverVars.hashDevice + data.type + data.share
                            };
                        hash(input);
                    },
                    "heartbeat-complete": function terminal_server_methodPOST_requestEnd_heartbeatComplete():void {
                        // * receipt of a heartbeat pulse on the distant end
                        heartbeat.parse(JSON.parse(body), serverResponse);
                    },
                    "heartbeat-delete-agents": function terminal_server_methodPOST_requestEnd_heartbeatDeleteAgents():void {
                        // * received instructions from remote to delete agents
                        heartbeat.deleteResponse(JSON.parse(body), serverResponse);
                    },
                    "heartbeat-status": function terminal_server_methodPOST_requestEnd_heartbeatStatus():void {
                        // * the response to a heartbeat at the original requestor
                        vars.broadcast("heartbeat-status", body);
                        response({
                            message: "heartbeat-status",
                            mimeType: "text/plain",
                            responseType: "heartbeat-status",
                            serverResponse: serverResponse
                        });
                    },
                    "heartbeat-update": function terminal_server_methodPOST_requestEnd_heartbeatUpdate():void {
                        // * prepare heartbeat pulse for connected agents
                        const dataPackage:heartbeatUpdate = JSON.parse(body);
                        dataPackage.response = serverResponse;
                        heartbeat.update(dataPackage);
                    },
                    "invite": function terminal_server_methodPOST_requestEnd_invite():void {
                        // * Handle all stages of invitation
                        invite(JSON.parse(body), serverResponse);
                    },
                    "message": function terminal_server_methodPOST_requestEnd_message():void {
                        // * process text messages
                        message(body, serverResponse);
                    },
                    "storage": function terminal_server_methodPOST_requestEnd_storage():void {
                        // * local: Writes changes to storage files
                        const dataPackage:storage = JSON.parse(body);
                        dataPackage.response = serverResponse;
                        storage(dataPackage);
                    },
                    "test-browser": function terminal_server_methodPOST_requestEnd_testBrowser():void {
                        // * validate a browser test iteration
                        browser.methods.route(JSON.parse(body), serverResponse);
                    }
                };
            if (actions[task] === undefined) {
                response({
                    message: `ForbiddenAccess: task ${task} not supported`,
                    mimeType: "text/plain",
                    responseType: "forbidden",
                    serverResponse: serverResponse
                });
            } else {
                actions[task]();
            }
        };

    // request handling
    request.on('data', function terminal_server_methodPOST_data(data:Buffer) {
        body = body + decoder.write(data);
        if (body.length > 1e6) {
            request.connection.destroy();
        }
    });
    request.on("error", function terminal_server_methodPOST_errorRequest(errorMessage:nodeError):void {
        if (errorMessage.code !== "ETIMEDOUT") {
            log([
                `${vars.text.cyan}POST request, ${request.headers["request-type"]}, methodPOST.ts${vars.text.none}`,
                body,
                vars.text.angry + errorMessage.toString() + vars.text.none,
                ""
            ]);
        }
    });
    serverResponse.on("error", function terminal_server_methodPOST_errorResponse(errorMessage:nodeError):void {
        if (errorMessage.code !== "ETIMEDOUT") {
            log([
                `${vars.text.cyan}POST response, ${request.headers["request-type"]}, methodPOST.ts${vars.text.none}`,
                body,
                vars.text.angry + errorMessage.toString() + vars.text.none,
                ""
            ]);
        }
    });

    // request callbacks
    request.on("end", requestEnd);
};

export default methodPOST;