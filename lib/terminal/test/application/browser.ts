
/* lib/terminal/test/application/browser - The functions necessary to run browser test automation. */

import { exec } from "child_process";
import { readdir } from "fs";
import { hostname } from "os";

import error from "../../utilities/error.js";
import humanTime from "../../utilities/humanTime.js";
import log from "../../utilities/log.js";
import remove from "../../commands/remove.js";
import sender from "../../server/transmission/sender.js";
import time from "../../utilities/time.js";
import transmit_http from "../../server/transmission/transmit_http.js";
import transmit_ws from "../../server/transmission/transmit_ws.js";
import vars from "../../utilities/vars.js";

import filePathDecode from "./browserUtilities/file_path_decode.js";
import machines from "./browserUtilities/machines.js";
import storage_removal from "./browserUtilities/storage_removal.js";
import test_device from "../samples/browser_device.js";
import test_self from "../samples/browser_self.js";
import test_user from "../samples/browser_user.js";

let finished:boolean = false,
    tests:testBrowserItem[];
const defaultCommand:commands = vars.environment.command,
    defaultAddresses:transmit_addresses_IP = vars.environment.addresses,
    defaultStorage:string = vars.path.settings,
    httpTemplate:config_http_request = {
        agent: "",
        agentType: "device",
        callback: null,
        ip: "",
        port: 0,
        payload: {
            data: null,
            service: "test-browser"
        },
        stream: false
    },
    /**
     * Methods associated with the browser test automation logic.
     * ```typescript
     * interface module_test_browserApplication {
     *     args       : config_test_browserExecute; // Default configuration object available to the entire test browser library. Over written by a configuration object of same type passed into the *methods.execute* method.
     *     exitMessage: string;                     // Stores an exit message string for availability to the entirety of the test browser application because this messaging is generated by one method and distributed by another.
     *     exitType   : 0 | 1;                      // Stores 0 or 1 depending upon whether to indicate a clean exit or exit with error.
     *     index      : number;                     // Stores the current test item index number.
     *     ip         : string;                     // Stores the IP address of the target machine for the current test index.
     *     methods: {
     *         close             : (data:service_testBrowser) => void;        // Sends a single that tests are complete and the respective browser window should close on the local device.
     *         delay             : (config:config_test_browserDelay) => void; // Provides a single point of logic to handle delays regardless of the cause, duration, or associated messaging.
     *         execute           : (args:config_test_browserExecute) => void; // Entry point to browser test automation that prepares the environment on the local device and tells the remote machines to reset their environments.
     *         exit              : (index:number) => void;                    // Closes out testing on the local device and informs remote machines that testing has concluded with the corresponding messaging and a single to close their respective browser window.
     *         iterate           : (index:number) => void;                    // Validates the next browser test is properly formed and then either sends it to a browser on the local device or to the correct machine.
     *         request           : (item:service_testBrowser) => void;        // Receives a test item on a remote machine for distribution to its browser for execution.  The result is sent back using *methods.respond*.
     *         ["reset-browser"] : (data:service_testBrowser) => void;        // Sends a reset request to the browser of any given machine to prepare to execute tests.
     *         ["reset-complete"]: () => void;                                // Instructions the given machine to remove artifacts from a prior test cycle. The local machine will then issue *reset-request* to remote machines.
     *         ["reset-request"] : (data:service_testBrowser) => void;        // Sends a reset request to remote machines informing them to reset their environment and prepare to listen for incoming test items. Method executed from *methods.execute*.
     *         respond           : (item:service_testBrowser) => void;        // On a remote machine receives test execution messaging from its local browser for transfer back to the originating machine.
     *         result            : (item:service_testBrowser) => void;        // Evaluation result provided by a browser and transforms that data into messaging for a human to read.
     *         route             : (socketData:socketData) => void;           // Entry point to the browser test automation library on all remote machines. Tasks are routed to the correct method based upon the action specified.
     *         sendBrowser       : (item:service_testBrowser) => void;        // Encapsulates the transmission logic to send tests to the local browser.
     *     };
     *     port        : number; // Stores the port number of the target machine for the current test index.
     *     remoteAgents: number; // Counts the remote agents that are reporting a ready status before executing the first test.
     * }
     * ``` */
    browser:module_test_browserApplication = {
        args: {
            callback: function terminal_test_application_browser_callback():void {
                return;
            },
            demo: false,
            mode: "self",
            noClose: false
        },
        exitMessage: "",
        exitType: 0,
        index: -1,
        ip: "",
        methods: {
            close: function terminal_test_application_browser_close(data:service_testBrowser):void {
                const close:service_testBrowser = {
                    action: "close",
                    exit: data.exit,
                    index: -1,
                    result: [],
                    test: null,
                    transfer: null
                };
                browser.methods.sendBrowser(close);
                log([data.exit]);
            },
            delay: function terminal_test_application_browser_delay(config:config_test_browserDelay):void {
                const wait:number = (config.browser === true)
                        ? 0
                        : config.delay,
                    seconds:string = (config.delay / 1000).toString(),
                    plural:string = (config.delay === 1000)
                        ? ""
                        : "s";
                if (config.delay > 0 && config.message !== "demo") {
                    log([`${humanTime(false)}Delaying for ${vars.text.cyan + seconds + vars.text.none} second${plural}: ${vars.text.cyan + config.message + vars.text.none}`]);
                }
                setTimeout(config.action, wait);
            },
            execute: function terminal_test_application_browser_execute(args:config_test_browserExecute):void {
                const hostnameString:string = hostname();

                log.title(`Browser Tests - ${args.mode}`, true);
                browser.args = args;
                if (args.mode === "self") {
                    tests = test_self;
                } else if (args.mode === "device") {
                    tests = test_device;
                } else if (args.mode === "user") {
                    tests = test_user;
                }
                vars.environment.command = "test_browser";
                vars.environment.addresses = {
                    IPv4: (machines[hostnameString] === undefined)
                        ? [machines.self.ip]
                        : [machines[hostnameString].ip],
                    IPv6: []
                };
                vars.test.browser = {
                    action: (args.mode === "remote")
                        ? "nothing"
                        : "reset-request",
                    exit: (vars.settings.verbose === true)
                        ? "verbose"
                        : "",
                    index: -1,
                    result: [],
                    test: null,
                    transfer: (args.mode === "remote")
                        ? null
                        : {
                            agent: "",
                            ip: vars.environment.addresses.IPv4[0],
                            port: vars.environment.ports.http
                        }
                };
                storage_removal(function terminal_test_application_browser_execute_remove():void {
                    const agents = function terminal_test_application_browser_execute_agents():void {
                            const list:string[] = Object.keys(machines),
                                listLength:number = list.length;
                            let index:number = 0;
                            log(["Preparing remote machines"]);
                            do {
                                if (list[index] !== "self") {
                                    httpTemplate.callback = null;
                                    httpTemplate.ip = machines[list[index]].ip;
                                    httpTemplate.port = machines[list[index]].port;
                                    httpTemplate.payload.data = vars.test.browser;
                                    transmit_http.request(httpTemplate);
                                }
                                index = index + 1;
                            } while (index < listLength);
                        },
                        reset = function terminal_test_application_browser_execute_reset():void {
                            browser.methods["reset-request"]({
                                action: "result",
                                exit: "",
                                index: 0,
                                result: [],
                                test: tests[0],
                                transfer: null
                            });
                        },
                        remote = function terminal_test_application_browser_execute_remoteServer():void {
                            log([`${vars.text.cyan}Environment ready. Listening for instructions...${vars.text.none}`]);
                        };
                    vars.test.type = `browser_${args.mode}` as testListType;
                    transmit_http.server({
                        browser: false,
                        host: "",
                        port: -1,
                        test: true
                    },
                    {
                        agent: "",
                        agentType: "device",
                        callback: (args.mode === "remote")
                            ? remote
                            : (args.mode === "self")
                                ? reset
                                : agents
                    });
                });
            },
            exit: function terminal_test_application_browser_exit(index:number):void {
                if (finished === true) {
                    return;
                }
                finished = true;
                const close:service_testBrowser = {
                        action: (browser.args.noClose === true)
                            ? "nothing"
                            : "close",
                        exit: browser.exitMessage,
                        index: index,
                        result: [],
                        test: null,
                        transfer: null
                    },
                    closing = (browser.args.noClose === true)
                        ? function terminal_test_application_browser_exit_noClose():void {
                            log([browser.exitMessage, "\u0007"], true);
                        }
                        : function terminal_test_application_browser_exit_closing():void {
                            browser.methods.sendBrowser(close);
                            browser.methods.delay({
                                action: function terminal_test_application_browser_exit_closing_delay():void {
                                    browser.index = -1;
                                    vars.environment.command = defaultCommand;
                                    vars.environment.addresses = defaultAddresses;
                                    vars.path.settings = defaultStorage;
                                    vars.test.browser = null;
                                    browser.args.callback(browser.exitMessage, browser.exitType);
                                },
                                browser: false,
                                delay: 1000,
                                message: "Closing out the test environment."
                            });
                        };
                if (browser.args.mode === "device" || browser.args.mode === "user") {
                    let count:number = 0;
                    const agents:string[] = Object.keys(machines);
                    agents.forEach(function terminal_test_application_browser_exit_agents(name:string):void {
                        if (name !== "self") {
                            httpTemplate.callback = function terminal_test_application_browser_exit_callback():void {
                                count = count + 1;
                                if (count === agents.length - 1) {
                                    closing();
                                }
                            };
                            httpTemplate.ip = machines[name].ip;
                            httpTemplate.port = machines[name].port;
                            httpTemplate.payload.data = close;
                            transmit_http.request(httpTemplate);
                        }
                    });
                } else {
                    closing();
                }
            },
            iterate: function terminal_test_application_browser_iterate(index:number):void {
                // not writing to settings
                if (finished === true) {
                    return;
                }
                let delayMessage:string = "",
                    delayBrowser:boolean = false;
                const logs:string[] = [
                        `Test ${index + 1} malformed: ${vars.text.angry + tests[index].name + vars.text.none}`,
                        ""
                    ],
                    wait:number = (function terminal_test_application_browser_iterate_wait():number {
                        const interactionLength:number = (tests[index].interaction === null)
                            ? 0
                            : tests[index].interaction.length;
                        let a:number = interactionLength,
                            value:number = 0,
                            count:number = 0;
                        if (a > 0) {
                            do {
                                a = a - 1;
                                if (tests[index].interaction[a].event === "wait") {
                                    value = Number(tests[index].interaction[a].value);
                                    if (isNaN(value) === false) {
                                        count = count + value;
                                    }
                                }
                            } while (a > 0);
                        }
                        value = 2000;
                        if (interactionLength > 0 && tests[index].interaction[0].event === "refresh" && tests[index + 1].machine !== "self" && count < value) {
                            delayMessage = "Providing remote machine browser time before a refresh.";
                            return value;
                        }
                        if (browser.args.demo === true && count < 501) {
                            return 500;
                        }
                        if (count > 0) {
                            delayBrowser = true;
                        }
                        return count;
                    }()),
                    waitText = function terminal_test_application_browser_iterate_waitText(machine:string):string {
                        return (delayMessage === "" && wait > 0)
                            ? `Pausing for 'wait' event in browser on machine ${machine}.`
                            : delayMessage;
                    },
            
                    // determine if non-interactive events have required matching data properties
                    validate = function terminal_test_application_browser_iterate_validate():boolean {
                        let a:number = 0;
                        const length:number = (tests[index].interaction === null)
                                ? 0
                                : tests[index].interaction.length,
                            eventName = function terminal_test_application_browser_iterate_validate_eventName(property:string):string {
                                return `   ${vars.text.angry}*${vars.text.none} Interaction ${a + 1} has event ${vars.text.cyan}setValue${vars.text.none} but no ${vars.text.angry + property + vars.text.none} property.`;
                            };
                        if (tests[index].delay === undefined && tests[index].unit.length < 1) {
                            logs.push("Test does not contain a delay test or test instances in its test array.");
                            return false;
                        }
                        if (length > 0) {
                            do {
                                if ((tests[index].interaction[a].event === "setValue" || tests[index].interaction[a].event === "keydown" || tests[index].interaction[a].event === "keyup") && tests[index].interaction[a].value === undefined) {
                                    logs.push(eventName("value"));
                                } else if (tests[index].interaction[a].event === "move" && tests[index].interaction[a].coords === undefined) {
                                    logs.push(eventName("coords"));
                                }
                                a = a + 1;
                            } while (a < length);
                        }
                        if (logs.length < 3) {
                            return true;
                        }
                        return false;
                    };
                // delay is necessary to prevent a race condition
                // * about 1 in 10 times this will fail following event "refresh"
                // * because vars.test.browser is not updated to methodGET library fast enough
                if (validate() === true) {
                    vars.test.browser = {
                        action: "result",
                        exit: "",
                        index: index,
                        result: [],
                        test: tests[index],
                        transfer: null
                    };
                    if (tests[index].machine === "self") {
                        tests[index] = filePathDecode(tests[index], "") as testBrowserItem;
                        if (index === 0 || (index > 0 && tests[index - 1].interaction[0].event !== "refresh")) {
                            browser.methods.delay({
                                action: function terminal_test_application_browser_iterate_selfDelay():void {
                                    browser.methods.sendBrowser(vars.test.browser);
                                },
                                browser: delayBrowser,
                                delay: wait,
                                message: waitText(tests[index].machine)
                            });
                        } else if (delayBrowser === true) {
                            const second:number = (wait / 1000),
                                plural:string = (second === 1)
                                    ? ""
                                    : "s";
                            log([`${humanTime(false)}Delaying for ${vars.text.cyan + second + vars.text.none} second${plural}: ${vars.text.cyan + waitText(tests[index].machine) + vars.text.none}`]);
                        }
                    } else {
                        browser.methods.delay({
                            action: function terminal_test_application_browser_iterate_agentDelay():void {
                                const payload:testBrowserTransfer = {
                                        agent: vars.settings.hashUser,
                                        ip: vars.environment.addresses.IPv4[0],
                                        port: vars.environment.ports.http
                                    };
                                vars.test.browser.action = "request";
                                vars.test.browser.transfer = payload;
                                httpTemplate.callback = function terminal_test_application_browser_iterate_httpClient():void {
                                    if (finished === true) {
                                        browser.methods.exit(index);
                                    }
                                };
                                httpTemplate.ip = machines[tests[index].machine].ip;
                                httpTemplate.port = machines[tests[index].machine].port;
                                httpTemplate.payload.data = vars.test.browser;
                                transmit_http.request(httpTemplate);
                            },
                            browser: delayBrowser,
                            delay: wait,
                            message: waitText(tests[index].machine)
                        });
                    }
                } else {
                    log(logs, true);
                    if (browser.args.noClose === false) {
                        process.exit(1);
                    }
                }
            },
            request: function terminal_test_application_browser_request(item:service_testBrowser):void {
                item.test = filePathDecode(item.test, "") as testBrowserItem;
                const route:service_testBrowser = {
                    action: "respond",
                    exit: "",
                    index: item.index,
                    result: [],
                    test: item.test,
                    transfer: null
                };
                item.action = "respond";
                vars.test.browser = item;
                browser.methods.sendBrowser(route);
                browser.ip = item.transfer.ip;
                browser.port = item.transfer.port;
            },
            ["reset-browser"]: function terminal_test_application_browser_resetBrowser(data:service_testBrowser):void {
                if (browser.args.mode === "remote") {
                    const payload:service_testBrowser = {
                        action: "reset-complete",
                        exit: "",
                        index: -1,
                        result: [],
                        test: null,
                        transfer: {
                            agent: "",
                            ip: vars.environment.addresses.IPv4[0],
                            port: vars.environment.ports.http
                        }
                    };
                    httpTemplate.callback = null;
                    httpTemplate.ip = data.transfer.ip;
                    httpTemplate.port = data.transfer.port;
                    httpTemplate.payload.data = payload;
                    transmit_http.request(httpTemplate);
                }
            },
            ["reset-complete"]: function terminal_test_application_browser_resetComplete():void {
                const list:string[] = Object.keys(machines),
                    listLength:number = list.length - 1,
                    boldGreen:string = vars.text.green + vars.text.bold,
                    color:string = (browser.remoteAgents === listLength - 1)
                        ? boldGreen
                        : vars.text.angry;
                browser.remoteAgents = browser.remoteAgents + 1;
                log([`Received ready state from ${color + browser.remoteAgents + vars.text.none} of ${boldGreen + listLength + vars.text.none} total machines.`]);
                if (browser.remoteAgents === listLength) {
                    log(["", "Executing tests"]);
                    browser.methods["reset-request"]({
                        action: "result",
                        exit: "",
                        index: 0,
                        result: [],
                        test: tests[0],
                        transfer: null
                    });
                }
            },
            ["reset-request"]: function terminal_test_application_browser_resetRequest(data:service_testBrowser):void {
                if (browser.args.mode !== "remote") {
                    data.action = "result";
                }
                vars.test.browser = data;
                readdir(vars.path.settings.slice(0, vars.path.settings.length - 1), function terminal_test_application_browser_resetRequest_readdir(dErr:Error, files:string[]):void {
                    if (dErr !== null) {
                        error([dErr.toString()]);
                        return;
                    }
                    const browserLaunch = function terminal_test_application_browser_resetRequest_readdir_browserLaunch():void {
                        const keyword:string = (process.platform === "darwin")
                                ? "open"
                                : (process.platform === "win32")
                                    ? "start"
                                    : "xdg-open",
                            port:string = (vars.environment.ports.http === 443)
                                ? ""
                                : `:${String(vars.environment.ports.http)}`,
                            verboseFlag:string = (data.exit === "verbose" || (browser.args.mode !== "remote" && vars.settings.verbose === true))
                                ? "test_browser_verbose"
                                : "test_browser",
                            path:string = `https://localhost${port}/?${verboseFlag}`,
                            // execute a browser by file path to the browser binary
                            browserCommand:string = (process.argv.length > 0 && (process.argv[0].indexOf("\\") > -1 || process.argv[0].indexOf("/") > -1))
                                ? (function terminal_test_application_browser_resetRequest_readdir_browserLaunch_browserCommand():string {
                                    if (process.platform === "win32") {
                                        // yes, this is ugly.  Windows old cmd shell doesn't play well with file paths
                                        process.argv[0] = `${process.argv[0].replace(/\\/g, "\"\\\"").replace("\"\\", "\\") + "\""}`;
                                    } else {
                                        process.argv[0] = `"${process.argv[0]}"`;
                                    }
                                    if (process.argv.length > 1) {
                                        return `${keyword} ${process.argv[0]} ${path} "${process.argv.slice(1).join(" ")}"`;
                                    }
                                    return `${keyword} ${process.argv[0]} ${path}`;
                                }())
                                : `${keyword} ${path}`,
                            child = function terminal_test_application_browser_resetRequest_readdir_browserLaunch_child(errs:Error, stdout:string, stderr:Buffer | string):void {
                                if (errs !== null) {
                                    error([errs.toString()]);
                                    return;
                                }
                                if (stdout !== "") {
                                    log([stdout]);
                                }
                                if (stderr !== "") {
                                    log([stderr.toString()]);
                                }
                            };
                        exec(browserCommand, {
                            cwd: vars.path.project
                        }, child);
                    },
                    start = function terminal_test_application_browser_resetRequest_readdir_start():void {
                        let length:number = files.length,
                            flags:number = length,
                            timeStore:[string, number] = time("Resetting Test Environment", false, 0);
                        log(["", "", timeStore[0]]);
                        vars.settings.device = {};
                        vars.settings.user = {};
                        if (length === 1) {
                            browserLaunch();
                        } else {
                            do {
                                length = length - 1;
                                if (files[length] !== "settings.txt") {
                                    remove(vars.path.settings + files[length], function terminal_test_application_browser_resetRequest_readdir_remove():void {
                                        flags = flags - 1;
                                        if (flags === 1) {
                                            browserLaunch();
                                        }
                                    });
                                }
                            } while (length > 0);
                        }
                    };
                    if (browser.args.mode === "remote") {
                        const close:service_testBrowser = {
                            action: "close",
                            exit: "",
                            index: -1,
                            result: [],
                            test: null,
                            transfer: null
                        };
                        browser.methods.sendBrowser(close);
                        browser.methods.delay({
                            action: start,
                            browser: false,
                            delay: 2000,
                            message: "Delaying to close any open browsers."
                        });
                    } else {
                        start();
                    }
                });
            },
            respond: function terminal_test_application_browser_respond(item:service_testBrowser): void {
                const route:service_testBrowser = {
                    action: "result",
                    exit: "",
                    index: item.index,
                    result: item.result,
                    test: null,
                    transfer: null
                };
                vars.test.browser.action = "nothing";
                httpTemplate.callback = null;
                httpTemplate.ip = browser.ip;
                httpTemplate.port = browser.port;
                httpTemplate.payload.data = route;
                transmit_http.request(httpTemplate);
            },
            result: function terminal_test_application_browser_result(item:service_testBrowser):void {
                if (finished === true) {
                    return;
                }
                let a:number = 0,
                    falseFlag:boolean = false;
                const result: [boolean, string, string][] = item.result,
                    index:number = item.index,
                    length:number = result.length,
                    delay:boolean = (tests[index].unit.length === 0),
                    completion = function terminal_test_application_browser_result_completion(pass:boolean):void {
                        const plural:string = (tests.length === 1)
                                ? ""
                                : "s",
                            totalTests:number = (function terminal_test_application_browser_result_completion_total():number {
                                // gathers a total count of tests
                                let aa:number = tests.length,
                                    bb:number = 0;
                                do {
                                    aa = aa - 1;
                                    bb = bb + tests[aa].unit.length;
                                    if (tests[aa].delay !== undefined) {
                                        bb = bb + 1;
                                    }
                                } while (aa > 0);
                                return bb;
                            }());
                        if (pass === true) {
                            const passPlural:string = (index === 1)
                                ? ""
                                : "s";
                            browser.exitMessage = `${humanTime(false) + vars.text.green + vars.text.bold}Passed${vars.text.none} all ${totalTests} evaluations from ${index + 1} test${passPlural}.`;
                            browser.methods.exit(index);
                            browser.exitType = 0;
                            return;
                        }
                        browser.exitMessage = `${humanTime(false) + vars.text.angry}Failed${vars.text.none} on test ${vars.text.angry + (index + 1) + vars.text.none}: "${vars.text.cyan + tests[index].name + vars.text.none}" out of ${tests.length} total test${plural} and ${totalTests} evaluations.`;
                        browser.methods.exit(index);
                        browser.exitType = 1;
                    },
                    summary = function terminal_test_application_browser_result_summary(pass:boolean):string {
                        const resultString:string = (pass === true)
                                ? `${vars.text.green}Passed`
                                : `${vars.text.angry}Failed`;
                        return `${humanTime(false) + resultString} ${browser.args.mode} ${index + 1}: ${vars.text.none + tests[index].name}`;
                    },
                    buildNode = function terminal_test_application_Browser_result_buildNode(config:testBrowserTest, elementOnly:boolean):string {
                        let b:number = 0;
                        const node:browserDOM[] = config.node,
                            property:string[] = config.target,
                            nodeLength:number = node.length,
                            propertyLength:number = property.length,
                            output:string[] = (config.target[0] === "window")
                                ? []
                                : ["document"];
                        if (nodeLength > 0) {
                            do {
                                output.push(".");
                                output.push(node[b][0]);
                                if (node[b][1] !== null) {
                                    output.push("(\"");
                                    output.push(node[b][1]);
                                    output.push("\")");
                                }
                                if (node[b][2] !== null) {
                                    output.push("[");
                                    output.push(node[b][2].toString());
                                    output.push("]");
                                }
                                b = b + 1;
                            } while (b < nodeLength);
                        }
                        if (config.type === "element" || elementOnly === true) {
                            return output.join("");
                        }
                        if (config.type === "attribute") {
                            output.push(".");
                            output.push("getAttribute(\"");
                            output.push(config.target[0]);
                            output.push("\")");
                        } else if (config.type === "property") {
                            b = 0;
                            do {
                                output.push(".");
                                output.push(config.target[b]);
                                b = b + 1;
                            } while (b < propertyLength);
                        }
                        return output.join("");
                    },
                    testString = function terminal_test_application_browser_result_testString(pass:boolean, config:testBrowserTest):string {
                        const valueStore:primitive = config.value,
                            valueType:string = typeof valueStore,
                            value = (valueStore === null)
                                ? "null"
                                : (valueType === "string")
                                    ? `"${valueStore}"`
                                    : String(valueStore),
                            star:string = `   ${vars.text.angry}*${vars.text.none} `,
                            resultString:string = (pass === true)
                                ? `${vars.text.green}Passed:`
                                : (config === tests[index].delay)
                                    ? `${vars.text.angry}Failed (delay timeout):`
                                    : `${vars.text.angry}Failed:`,
                            qualifier:string = (config.qualifier === "begins")
                                ? (pass === true)
                                    ? "begins with"
                                    : `${vars.text.angry}does not begin with${vars.text.none}`
                                : (config.qualifier === "contains")
                                    ? (pass === true)
                                        ? "contains"
                                        : `${vars.text.angry}does not contain${vars.text.none}`
                                    : (config.qualifier === "ends")
                                        ? (pass === true)
                                            ? "ends with"
                                            : `${vars.text.angry}does not end with${vars.text.none}`
                                        : (config.qualifier === "greater")
                                            ? (pass === true)
                                                ? "is greater than"
                                                : `${vars.text.angry}is not greater than${vars.text.none}`
                                            : (config.qualifier === "is")
                                                ? (pass === true)
                                                    ? "is"
                                                    : `${vars.text.angry}is not${vars.text.none}`
                                                : (config.qualifier === "lesser")
                                                    ? (pass === true)
                                                        ? "is less than"
                                                        : `${vars.text.angry}is not less than${vars.text.none}`
                                                    : (config.qualifier === "not")
                                                        ? (pass === true)
                                                            ? "is not"
                                                            : `${vars.text.angry}is${vars.text.none}`
                                                        : (pass === true)
                                                            ? "does not contain"
                                                            : `${vars.text.angry}contains${vars.text.none}`,
                            nodeString = `${vars.text.none} ${buildNode(config, false)} ${qualifier}\n${value.replace(/^"/, "").replace(/"$/, "")}`;
                        return star + resultString + nodeString;
                    },
                    failureMessage = function terminal_test_application_browser_result_failureMessage():void {
                        if (result[a][2] === "error") {
                            const error:string = result[a][1]
                                .replace("{\"file\":"   , `{\n    "${vars.text.cyan}file${vars.text.none}"   :`)
                                .replace(",\"column\":" , `,\n    "${vars.text.cyan}column${vars.text.none}" :`)
                                .replace(",\"line\":"   , `,\n    "${vars.text.cyan}line${vars.text.none}"   :`)
                                .replace(",\"message\":", `,\n    "${vars.text.cyan}message${vars.text.none}":`)
                                .replace(",\"stack\":\"", `,\n    "${vars.text.cyan}stack${vars.text.none}"  :\n        `)
                                .replace(/\\n/g, "\n        ")
                                .replace(/@http/g, "  -  http")
                                .replace(/\s*"\s*\}$/, "\n}");
                            failure.push(`     ${vars.text.angry}JavaScript Error${vars.text.none}\n${error}`);
                        } else if (result[a][1].indexOf("Bad test. ") === 0) {
                            const segments:string[] = result[a][1].split(": [");
                            failure.push(`     ${segments[0].replace("Bad test.", `${vars.text.angry}Bad test.${vars.text.none}`)}.`);
                            if (segments.length > 1) {
                                failure.push(`     Provided: ${vars.text.angry}[${segments[1] + vars.text.none}`);
                            }
                            failure.push(`     ${vars.text.cyan + result[a][2] + vars.text.none}`);
                        } else if ((delay === false && result[a][2] === buildNode(tests[index].unit[a], true)) || (delay === true && result[a][2] === buildNode(tests[index].delay, true))) {
                            failure.push(`     ${vars.text.green}Actual value:${vars.text.none}\n${vars.text.cyan + result[a][1].replace(/^"/, "").replace(/"$/, "").replace(/\\"/g, "\"") + vars.text.none}`);
                        } else if ((delay === false && tests[index].unit[a].value === null) || (delay === true && tests[index].delay.value === null)) {
                            failure.push(`     DOM node is not null: ${vars.text.cyan + result[a][2] + vars.text.none}`);
                        } else if ((delay === false && tests[index].unit[a].value === undefined) || (delay === true && tests[index].delay.value === undefined)) {
                            failure.push(`     DOM node is not undefined: ${vars.text.cyan + result[a][2] + vars.text.none}`);
                        } else {
                            failure.push(`     DOM node is ${result[a][1]}: ${vars.text.cyan + result[a][2] + vars.text.none}`);
                        }
                    },
                    failure:string[] = [];

                if (browser.index < index) {
                    browser.index = index;
                    if (result[0][0] === false && result[0][1] === "delay timeout") {
                        failure.push(testString(false, tests[index].delay));
                        if (tests[index].delay.type === "element") {
                            const qualifier:string = (tests[index].delay.qualifier === "not")
                                ? " not"
                                : "";
                            failure.push(`     DOM node is${qualifier} ${tests[index].delay.value}: ${vars.text.cyan + result[1][1] + vars.text.none}`);
                        } else {
                            failure.push(`     ${vars.text.green}Actual value:${vars.text.none}\n${vars.text.cyan + result[1][1].replace(/^"/, "").replace(/"$/, "").replace(/\\"/g, "\"") + vars.text.none}`);
                        }
                        falseFlag = true;
                    } else if (result[0][0] === false && result[0][1].indexOf("event error ") === 0) {
                        failure.push(`${vars.text.angry}Failed: event node is ${result[0][1].replace("event error ", "")}`);
                        failure.push(`     Specified event node is: ${vars.text.cyan + result[0][2] + vars.text.none}`);
                        falseFlag = true;
                    } else if (delay === true) {
                        failure.push(testString(result[a][0], tests[index].delay));
                        if (result[a][0] === false) {
                            failureMessage();
                            falseFlag = true;
                        }
                    } else {
                        do {
                            failure.push(testString(result[a][0], tests[index].unit[a]));
                            if (result[a][0] === false) {
                                failureMessage();
                                falseFlag = true;
                            }
                            a = a + 1;
                        } while (a < length);
                    }

                    if (falseFlag === true) {
                        failure.splice(0, 0, summary(false));
                        log(failure);
                        completion(false);
                        return;
                    }
                    log([summary(true)]);
                    if (index + 1 < tests.length) {
                        browser.methods.iterate(index + 1);
                    } else {
                        completion(true);
                    }
                }
            },
            route: function terminal_test_application_browser_route(socketData:socketData):void {
                const data:service_testBrowser = socketData.data as service_testBrowser;

                if (vars.settings.verbose === true) {
                    log([`On terminal receiving test index ${data.index}`]);
                }
                if (data.action !== "nothing" && data.action !== "reset-response") {
                    if (browser.methods[data.action] === undefined) {
                        error([`Unsupported action in browser test automation: ${data.action}`]);
                    } else {
                        browser.methods[data.action](data);
                    }
                } else if (data.exit !== "") {
                    log([data.exit]);
                }
                // close
                // * tells the test browser to close
                // * from browser.exit on mode:agents sent to mode:remote
                // -
                // request
                // * sends a test from mode:agents to a specified mode:remote
                // * from browser.iterate
                // * sends an unused HTTP response
                // -
                // reset-browser
                // * indicates the environment is reset and the browser is ready on the local computer (mode:remote)
                // * from the browser
                // * send an HTTP request to data.transfer identifiers
                // -
                // reset-complete
                // * confirms that the remote computers are reset and their web browsers are ready to execute
                // * from resetResponse of mode:remote sent to mode:agents
                // * executes local reset-request thus beginning test iteration
                // -
                // reset-request
                // * resets the environment on mode:remote
                // * from mode:agent (remote) in browser.execute to this computer mode:remote
                // * generates an HTTP response
                // -
                // respond
                // * converts an action 'request' into a test for the browser of a specified mode:remote
                // * from browser.request of mode:agents (remote)
                // * sends an HTTP request to browser.ip with the test result
                // -
                // result
                // * response to test completion
                // * from browsers whether local or remote
                // * calls browser.iterate
            },
            sendBrowser: function terminal_test_application_browser_sendBrowser(item:service_testBrowser):void {
                const keys:string[] = Object.keys(transmit_ws.clientList.browser);
                if (vars.settings.verbose === true) {
                    log([`On terminal sending test index ${item.index}`]);
                }
                sender.send({
                    data: item,
                    service: "test-browser"
                }, {
                    device: keys[keys.length - 1],
                    user: "browser"
                });
            }
        },
        port: 0,
        remoteAgents: 0
    };

export default browser;